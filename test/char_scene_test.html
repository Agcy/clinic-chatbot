<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Three.js 医疗对话场景测试</title>
    <style>
        body { margin: 0; overflow: hidden; } /* 移除边距并隐藏滚动条 */
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@latest/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        // GLTFLoader 用于加载 glTF/glb 格式的模型
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        // OrbitControls 用于鼠标控制镜头，方便调试
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, characterModel, backgroundModel, mixer, clock;
        let talkingAction; // 存储说话动画

        init();
        animate();

        function init() {
            // 1. 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // 天蓝色背景，可替换为模型或图片

            // 2. 创建相机 (透视相机)
            // PerspectiveCamera(fov, aspect, near, far)
            // fov: 视野角度; aspect: 宽高比; near: 近裁剪面; far: 远裁剪面
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0.7, 2); // 将相机放在人物前方稍高一点的位置 (x, y, z)
            camera.lookAt(0, 0.7, 2); // 相机朝向人物胸部或头部

            // 3. 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.4; // 降低曝光度，尝试这个值
            document.body.appendChild(renderer.domElement);

            // 4.1. 半球光 - 提供柔和的环境光照
            const hemisphereLight = new THREE.HemisphereLight(
                0xffffff,  // 天空色
                0x8d8d8d,  // 地面色
                6.0        // 降低强度，避免过曝
            );
            hemisphereLight.position.set(0, 10, 0);
            scene.add(hemisphereLight);

            // 4.2. 主平行光 - 模拟主要光源（如太阳光）
            const mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 3.0);
            mainDirectionalLight.position.set(5, 5, 2); // 从右前方打光
            mainDirectionalLight.castShadow = true;     // 启用阴影
            scene.add(mainDirectionalLight);

            // 4.3 环境光 - 提供基础环境照明
            const ambientLight = new THREE.AmbientLight(0xffffff, 5);
            scene.add(ambientLight);

            // 5. OrbitControls (可选，方便调试)
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0); // 控制器围绕的点
            controls.update();

            // 6. Clock (用于动画)
            clock = new THREE.Clock();

            // 7. 加载模型 (稍后实现)
            loadModels();

            // 8. 监听窗口大小变化
            window.addEventListener('resize', onWindowResize, false);

            // 模拟TTS调用的按钮 (用于测试动画)
            createTestButtons();
        }

        function loadModels() {
            const loader = new GLTFLoader();

            // 加载背景模型 (示例，你需要替换成你的模型路径)
            loader.load('/public/model/operation_room.glb', function (gltf) {
                backgroundModel = gltf.scene;
                backgroundModel.position.set(0, -0.5, 0); // 调整背景位置
                scene.add(backgroundModel);
            }, undefined, function (error) {
                console.error('加载背景模型失败:', error);
            });
            // 如果暂时没有背景模型，可以用一张图片作为背景
            // const textureLoader = new THREE.TextureLoader();
            // textureLoader.load('/public/assets/hospital_background.jpeg', function(texture) { // 替换为你的背景图片路径
            //     scene.background = texture;
            // }, undefined, function(err) {
            //     console.error('背景图片加载失败，将使用纯色背景。', err);
            //     scene.background = new THREE.Color(0xDDDDDD); // 加载失败则用浅灰色
            // });


            // 加载人物模型 (示例，你需要替换成你的模型路径)
            // 确保模型文件放在可以访问到的地方，例如项目的 public 文件夹
            loader.load('/public/model/doctor.glb', function (gltf) {
                characterModel = gltf.scene;
                characterModel.position.set(0, -0.5, 0);

                // 打印所有动画信息
                console.log('模型包含的所有动画：');
                gltf.animations.forEach((animation, index) => {
                    console.log(`动画 ${index + 1}:`);
                    console.log(`- 名称: ${animation.name}`);
                    console.log(`- 持续时间: ${animation.duration}秒`);
                    console.log(`- 轨道数量: ${animation.tracks.length}`);
                    console.log('------------------------');
                });

                // characterModel.rotation.y = THREE.MathUtils.degToRad(-25);
                scene.add(characterModel);
                
                // --- 调整人物大小 ---
                // const desiredScale = 1; // 尝试不同的值，比如 1.0, 1.5, 2.0 等，直到满意为止
                // characterModel.scale.set(desiredScale, desiredScale, desiredScale);

                // --- 处理动画 ---
                if (gltf.animations && gltf.animations.length) {
                    mixer = new THREE.AnimationMixer(characterModel);

                    // 获取 idle 和 talk 动画片段
                    const idleClip = THREE.AnimationClip.findByName(gltf.animations, 'idle');
                    const talkClip = THREE.AnimationClip.findByName(gltf.animations, 'talk');

                    let idleAction, talkingAction;

                    if (idleClip) {
                        idleAction = mixer.clipAction(idleClip);
                        // 设置 idle 动画为循环播放
                        idleAction.setLoop(THREE.LoopRepeat);
                        // 立即开始播放 idle 动画
                        idleAction.play();
                    }

                    if (talkClip) {
                        talkingAction = mixer.clipAction(talkClip);
                    }

                    // 修改全局的动画控制函数
                    window.playTalkAnimation = function(play) {
                        if (!talkingAction || !idleAction) {
                            console.warn("动画尚未准备好。");
                            return;
                        }
                        
                        if (play) {
                            // 开始说话：淡出 idle，淡入 talk
                            idleAction.fadeOut(0.5);
                            talkingAction.reset().fadeIn(0.5).play();
                        } else {
                            // 停止说话：淡出 talk，淡入 idle
                            talkingAction.fadeOut(0.5);
                            idleAction.reset().fadeIn(0.5).play();
                        }
                    }
                } else {
                    console.warn('模型不包含动画数据。');
                }

            }, undefined, function (error) {
                console.error('加载人物模型失败:', error);
            });
        }

        function createTestButtons() {
            const buttonStart = document.createElement('button');
            buttonStart.textContent = '开始说话 (模拟)';
            buttonStart.style.position = 'absolute';
            buttonStart.style.top = '10px';
            buttonStart.style.left = '10px';
            buttonStart.onclick = () => window.playTalkAnimation(true);
            document.body.appendChild(buttonStart);

            const buttonStop = document.createElement('button');
            buttonStop.textContent = '停止说话 (模拟)';
            buttonStop.style.position = 'absolute';
            buttonStop.style.top = '50px';
            buttonStop.style.left = '10px';
            buttonStop.onclick = () => window.playTalkAnimation(false);
            document.body.appendChild(buttonStop);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate); // 请求下一帧

            const delta = clock.getDelta(); // 获取自上一帧以来的时间差
            if (mixer) {
                mixer.update(delta); // 更新动画混合器
            }

            renderer.render(scene, camera); // 渲染场景
        }
    </script>
</body>
</html>