<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Three.js 医疗对话场景测试与配置</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #controlsPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 5px;
            width: 280px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }
        #controlsPanel h3 { margin-top: 0; }
        #controlsPanel label {
            display: inline-block;
            width: 60px;
            margin-right: 5px;
            text-align: right;
        }
        #controlsPanel input[type="number"] {
            width: 70px;
            margin-bottom: 5px;
            padding: 3px;
        }
        #controlsPanel .input-group { margin-bottom: 10px; }
        #controlsPanel button {
            display: block;
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #controlsPanel button:hover { background-color: #45a049; }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 5px;
        }
        .modal-content label { display: block; margin-bottom: 5px; }
        .modal-content input[type="text"], .modal-content textarea {
            width: calc(100% - 12px);
            padding: 5px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .modal-content button {
            padding: 10px 15px;
            margin-right: 10px;
            cursor: pointer;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="controlsPanel">
        <h3>模型控制</h3>
        <div id="characterControls">
            <h4>角色模型</h4>
            <div class="input-group">
                <label for="charPosX">Pos X:</label><input type="number" id="charPosX" step="0.1">
                <label for="charPosY">Y:</label><input type="number" id="charPosY" step="0.1">
                <label for="charPosZ">Z:</label><input type="number" id="charPosZ" step="0.1">
            </div>
            <div class="input-group">
                <label for="charRotX">Rot X:</label><input type="number" id="charRotX" step="1">
                <label for="charRotY">Y:</label><input type="number" id="charRotY" step="1">
                <label for="charRotZ">Z:</label><input type="number" id="charRotZ" step="1">
            </div>
        </div>
        <div id="backgroundControls">
            <h4>场景模型</h4>
            <div class="input-group">
                <label for="bgPosX">Pos X:</label><input type="number" id="bgPosX" step="0.1">
                <label for="bgPosY">Y:</label><input type="number" id="bgPosY" step="0.1">
                <label for="bgPosZ">Z:</label><input type="number" id="bgPosZ" step="0.1">
            </div>
            <div class="input-group">
                <label for="bgRotX">Rot X:</label><input type="number" id="bgRotX" step="1">
                <label for="bgRotY">Y:</label><input type="number" id="bgRotY" step="1">
                <label for="bgRotZ">Z:</label><input type="number" id="bgRotZ" step="1">
            </div>
        </div>
        <button id="saveConfigButton">保存配置到数据库</button>
        <div id="messageArea" style="margin-top: 10px; text-align: center;"></div>
    </div>

    <div id="saveModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeModalButton">&times;</span>
            <h3>保存场景配置</h3>
            <label for="configIdInput">Config ID:</label>
            <input type="text" id="configIdInput" placeholder="例如: doctor-office-view1">
            <label for="configNameInput">配置名称:</label>
            <input type="text" id="configNameInput" placeholder="例如: 医生办公室视角一">
            <label for="configDescriptionInput">描述:</label>
            <textarea id="configDescriptionInput" rows="3" placeholder="场景的简短描述"></textarea>
            <button id="confirmSaveButton">确认保存</button>
            <button id="cancelSaveButton">取消</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@latest/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, characterModel, backgroundModel, mixer, clock, controls;
        let talkingAction; 
        let characterModelURL = '/public/model/patient.glb';
        let backgroundModelURL = '/public/model/operation_room.glb';

        // DOM Elements for controls
        let charPosXInput, charPosYInput, charPosZInput, charRotXInput, charRotYInput, charRotZInput;
        let bgPosXInput, bgPosYInput, bgPosZInput, bgRotXInput, bgRotYInput, bgRotZInput;
        let saveConfigButton, saveModal, closeModalButton, confirmSaveButton, cancelSaveButton;
        let configIdInput, configNameInput, configDescriptionInput, messageArea;
        let hemisphereLight, mainDirectionalLight, ambientLight;

        // 等待 DOM 加载完成后再初始化
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM加载完成，开始获取DOM元素...');
            
            // 获取所有DOM元素
            charPosXInput = document.getElementById('charPosX');
            charPosYInput = document.getElementById('charPosY');
            charPosZInput = document.getElementById('charPosZ');
            charRotXInput = document.getElementById('charRotX');
            charRotYInput = document.getElementById('charRotY');
            charRotZInput = document.getElementById('charRotZ');

            bgPosXInput = document.getElementById('bgPosX');
            bgPosYInput = document.getElementById('bgPosY');
            bgPosZInput = document.getElementById('bgPosZ');
            bgRotXInput = document.getElementById('bgRotX');
            bgRotYInput = document.getElementById('bgRotY');
            bgRotZInput = document.getElementById('bgRotZ');
            
            saveConfigButton = document.getElementById('saveConfigButton');
            saveModal = document.getElementById('saveModal');
            closeModalButton = document.getElementById('closeModalButton');
            confirmSaveButton = document.getElementById('confirmSaveButton');
            cancelSaveButton = document.getElementById('cancelSaveButton');
            configIdInput = document.getElementById('configIdInput');
            configNameInput = document.getElementById('configNameInput');
            configDescriptionInput = document.getElementById('configDescriptionInput');
            messageArea = document.getElementById('messageArea');

            console.log('DOM元素获取完成，开始初始化3D场景...');
            init();
            animate();
        });

        function init() {
            console.log('初始化开始...'); // 调试日志
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0.7, 2); 
            camera.lookAt(0, 0.7, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.4;
            document.body.appendChild(renderer.domElement);

            hemisphereLight = new THREE.HemisphereLight(
                0xffffff,
                0x8d8d8d,
                6.0
            );
            hemisphereLight.position.set(0, 10, 0);
            scene.add(hemisphereLight);

            mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 3.0);
            mainDirectionalLight.position.set(5, 5, 2);
            mainDirectionalLight.castShadow = true;
            scene.add(mainDirectionalLight);

            ambientLight = new THREE.AmbientLight(0xffffff, 5);
            scene.add(ambientLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0.7, 0);
            controls.update();

            clock = new THREE.Clock();

            loadModels();
            setupEventListeners();
            window.addEventListener('resize', onWindowResize, false);
            createTestButtons();
            
            console.log('初始化完成，事件监听器已设置'); // 调试日志
        }

        function updateInputFields(model, type) {
            if (!model) return;
            const prefix = type === 'char' ? 'char' : 'bg';
            const posXInput = document.getElementById(`${prefix}PosX`);
            const posYInput = document.getElementById(`${prefix}PosY`);
            const posZInput = document.getElementById(`${prefix}PosZ`);
            const rotXInput = document.getElementById(`${prefix}RotX`);
            const rotYInput = document.getElementById(`${prefix}RotY`);
            const rotZInput = document.getElementById(`${prefix}RotZ`);

            posXInput.value = model.position.x.toFixed(2);
            posYInput.value = model.position.y.toFixed(2);
            posZInput.value = model.position.z.toFixed(2);
            rotXInput.value = THREE.MathUtils.radToDeg(model.rotation.x).toFixed(1);
            rotYInput.value = THREE.MathUtils.radToDeg(model.rotation.y).toFixed(1);
            rotZInput.value = THREE.MathUtils.radToDeg(model.rotation.z).toFixed(1);
        }
        
        function setupModelControls(model, type) {
            if (!model) return;
            const prefix = type === 'char' ? 'char' : 'bg';
            const posXInput = document.getElementById(`${prefix}PosX`);
            const posYInput = document.getElementById(`${prefix}PosY`);
            const posZInput = document.getElementById(`${prefix}PosZ`);
            const rotXInput = document.getElementById(`${prefix}RotX`);
            const rotYInput = document.getElementById(`${prefix}RotY`);
            const rotZInput = document.getElementById(`${prefix}RotZ`);

            posXInput.addEventListener('input', (e) => model.position.x = parseFloat(e.target.value));
            posYInput.addEventListener('input', (e) => model.position.y = parseFloat(e.target.value));
            posZInput.addEventListener('input', (e) => model.position.z = parseFloat(e.target.value));
            rotXInput.addEventListener('input', (e) => model.rotation.x = THREE.MathUtils.degToRad(parseFloat(e.target.value)));
            rotYInput.addEventListener('input', (e) => model.rotation.y = THREE.MathUtils.degToRad(parseFloat(e.target.value)));
            rotZInput.addEventListener('input', (e) => model.rotation.z = THREE.MathUtils.degToRad(parseFloat(e.target.value)));
            
            // Initial population
            updateInputFields(model, type);
        }

        function loadModels() {
            const loader = new GLTFLoader();

            // 加载背景模型 (示例，你需要替换成你的模型路径)
            loader.load(backgroundModelURL, function (gltf) {
                if (backgroundModel) scene.remove(backgroundModel); // Remove old if exists
                backgroundModel = gltf.scene;
                backgroundModel.position.set(0, -0.5, 0); // 调整背景位置
                scene.add(backgroundModel);
                setupModelControls(backgroundModel, 'bg');
            }, undefined, function (error) {
                console.error('加载背景模型失败:', error);
                messageArea.textContent = `背景模型加载失败: ${backgroundModelURL}`;
            });
            // 如果暂时没有背景模型，可以用一张图片作为背景
            // const textureLoader = new THREE.TextureLoader();
            // textureLoader.load('/public/assets/hospital_background.jpeg', function(texture) { // 替换为你的背景图片路径
            //     scene.background = texture;
            // }, undefined, function(err) {
            //     console.error('背景图片加载失败，将使用纯色背景。', err);
            //     scene.background = new THREE.Color(0xDDDDDD); // 加载失败则用浅灰色
            // });


            // 加载人物模型 (示例，你需要替换成你的模型路径)
            // 确保模型文件放在可以访问到的地方，例如项目的 public 文件夹
            loader.load(characterModelURL, function (gltf) {
                if (characterModel) scene.remove(characterModel); // Remove old if exists
                characterModel = gltf.scene;
                characterModel.position.set(0, -0.5, 0);

                // 打印所有动画信息
                console.log('模型包含的所有动画：');
                gltf.animations.forEach((animation, index) => {
                    console.log(`动画 ${index + 1}:`);
                    console.log(`- 名称: ${animation.name}`);
                    console.log(`- 持续时间: ${animation.duration}秒`);
                    console.log(`- 轨道数量: ${animation.tracks.length}`);
                    console.log('------------------------');
                });

                // characterModel.rotation.y = THREE.MathUtils.degToRad(-25);
                scene.add(characterModel);
                
                // --- 调整人物大小 ---
                // const desiredScale = 1; // 尝试不同的值，比如 1.0, 1.5, 2.0 等，直到满意为止
                // characterModel.scale.set(desiredScale, desiredScale, desiredScale);

                // --- 处理动画 ---
                if (gltf.animations && gltf.animations.length) {
                    mixer = new THREE.AnimationMixer(characterModel);

                    // 获取 idle 和 talk 动画片段
                    const idleClip = THREE.AnimationClip.findByName(gltf.animations, 'idle');
                    const talkClip = THREE.AnimationClip.findByName(gltf.animations, 'talk');

                    let idleAction, talkingAction;

                    if (idleClip) {
                        idleAction = mixer.clipAction(idleClip);
                        // 设置 idle 动画为循环播放
                        idleAction.setLoop(THREE.LoopRepeat);
                        // 立即开始播放 idle 动画
                        idleAction.play();
                    }

                    if (talkClip) {
                        talkingAction = mixer.clipAction(talkClip);
                    }

                    // 修改全局的动画控制函数
                    window.playTalkAnimation = function(play) {
                        if (!talkingAction || !idleAction) {
                            console.warn("动画尚未准备好。");
                            return;
                        }
                        
                        if (play) {
                            // 开始说话：淡出 idle，淡入 talk
                            idleAction.fadeOut(0.5);
                            talkingAction.reset().fadeIn(0.5).play();
                        } else {
                            // 停止说话：淡出 talk，淡入 idle
                            talkingAction.fadeOut(0.5);
                            idleAction.reset().fadeIn(0.5).play();
                        }
                    }
                } else {
                    console.warn('模型不包含动画数据。');
                }

                setupModelControls(characterModel, 'char');

            }, undefined, function (error) {
                console.error('加载人物模型失败:', error);
                messageArea.textContent = `角色模型加载失败: ${characterModelURL}`;
            });
        }

        function createTestButtons() {
            const buttonStart = document.createElement('button');
            buttonStart.textContent = '开始说话 (模拟)';
            buttonStart.style.position = 'absolute';
            buttonStart.style.top = '10px';
            buttonStart.style.left = '10px';
            buttonStart.style.zIndex = '10'; // Ensure above controls panel if overlapping
            buttonStart.onclick = () => window.playTalkAnimation(true);
            document.body.appendChild(buttonStart);

            const buttonStop = document.createElement('button');
            buttonStop.textContent = '停止说话 (模拟)';
            buttonStop.style.position = 'absolute';
            buttonStop.style.top = '50px';
            buttonStop.style.left = '10px';
            buttonStop.style.zIndex = '10';
            buttonStop.onclick = () => window.playTalkAnimation(false);
            document.body.appendChild(buttonStop);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate); // 请求下一帧

            const delta = clock.getDelta(); // 获取自上一帧以来的时间差
            if (mixer) {
                mixer.update(delta); // 更新动画混合器
            }

            controls.update(); // Required if controls.enableDamping or controls.autoRotate are set true
            renderer.render(scene, camera); // 渲染场景
        }

        function setupEventListeners() {
            console.log('正在设置事件监听器...'); // 调试日志
            
            // 验证DOM元素是否存在
            if (!saveConfigButton) {
                console.error('未找到保存配置按钮元素！');
                return;
            }
            if (!saveModal) {
                console.error('未找到模态框元素！');
                return;
            }
            if (!closeModalButton) {
                console.error('未找到关闭按钮元素！');
                return;
            }
            if (!confirmSaveButton) {
                console.error('未找到确认保存按钮元素！');
                return;
            }
            if (!cancelSaveButton) {
                console.error('未找到取消按钮元素！');
                return;
            }
            
            saveConfigButton.addEventListener('click', () => {
                console.log('"保存配置到数据库"按钮被点击');
                saveModal.style.display = 'block';
                messageArea.textContent = '';
            });
            
            closeModalButton.addEventListener('click', () => {
                console.log('关闭模态框按钮被点击');
                saveModal.style.display = 'none';
            });
            
            cancelSaveButton.addEventListener('click', () => {
                console.log('取消保存按钮被点击');
                saveModal.style.display = 'none';
            });
            
            confirmSaveButton.addEventListener('click', () => {
                console.log('确认保存按钮被点击');
                handleSaveConfiguration();
            });

            window.onclick = function(event) {
                if (event.target == saveModal) {
                    saveModal.style.display = "none";
                }
            }
            
            console.log('事件监听器设置完成'); // 调试日志
        }
        
        async function handleSaveConfiguration() {
            const configId = configIdInput.value.trim();
            const name = configNameInput.value.trim();
            const description = configDescriptionInput.value.trim();

            if (!configId || !name) {
                alert('Config ID 和配置名称不能为空！');
                return;
            }
            if (!characterModel || !backgroundModel) {
                alert('模型尚未加载完成，请稍后再试。');
                return;
            }

            // 从输入框获取位置和旋转值
            const charPosition = {
                x: parseFloat(document.getElementById('charPosX').value),
                y: parseFloat(document.getElementById('charPosY').value),
                z: parseFloat(document.getElementById('charPosZ').value)
            };
            
            // 将度数转换为弧度后保存
            const charRotation = {
                x: THREE.MathUtils.degToRad(parseFloat(document.getElementById('charRotX').value)),
                y: THREE.MathUtils.degToRad(parseFloat(document.getElementById('charRotY').value)),
                z: THREE.MathUtils.degToRad(parseFloat(document.getElementById('charRotZ').value))
            };

            const bgPosition = {
                x: parseFloat(document.getElementById('bgPosX').value),
                y: parseFloat(document.getElementById('bgPosY').value),
                z: parseFloat(document.getElementById('bgPosZ').value)
            };
            
            // 将度数转换为弧度后保存
            const bgRotation = {
                x: THREE.MathUtils.degToRad(parseFloat(document.getElementById('bgRotX').value)),
                y: THREE.MathUtils.degToRad(parseFloat(document.getElementById('bgRotY').value)),
                z: THREE.MathUtils.degToRad(parseFloat(document.getElementById('bgRotZ').value))
            };

            const configData = {
                configId: configId,
                name: name,
                description: description,
                sceneModel: {
                    url: backgroundModelURL,
                    position: bgPosition,
                    rotation: bgRotation,
                    scale: { x: backgroundModel.scale.x, y: backgroundModel.scale.y, z: backgroundModel.scale.z }
                },
                characterModel: {
                    url: characterModelURL,
                    position: charPosition,
                    rotation: charRotation,
                    scale: { x: characterModel.scale.x, y: characterModel.scale.y, z: characterModel.scale.z }
                },
                camera: {
                    position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    lookAt: { x: controls.target.x, y: controls.target.y, z: controls.target.z },
                    fov: camera.fov,
                    near: camera.near,
                    far: camera.far
                },
                lighting: {
                    hemisphereLight: {
                        skyColor: `#${hemisphereLight.color.getHexString()}`,
                        groundColor: `#${hemisphereLight.groundColor.getHexString()}`,
                        intensity: hemisphereLight.intensity,
                        position: { x: hemisphereLight.position.x, y: hemisphereLight.position.y, z: hemisphereLight.position.z }
                    },
                    directionalLight: {
                        color: `#${mainDirectionalLight.color.getHexString()}`,
                        intensity: mainDirectionalLight.intensity,
                        position: { x: mainDirectionalLight.position.x, y: mainDirectionalLight.position.y, z: mainDirectionalLight.position.z },
                        castShadow: mainDirectionalLight.castShadow
                    },
                    ambientLight: {
                        color: `#${ambientLight.color.getHexString()}`,
                        intensity: ambientLight.intensity
                    }
                },
                background: {
                    type: "color",
                    value: `#${scene.background.getHexString()}`
                },
                renderer: {
                    toneMappingExposure: renderer.toneMappingExposure,
                    toneMapping: "ACESFilmicToneMapping"
                }
            };

            try {
                // 读取现有的配置文件
                const response = await fetch('/public/prompts/scene_3d_config.json');
                let existingConfigs = [];
                
                if (response.ok) {
                    existingConfigs = await response.json();
                } else {
                    console.warn('无法读取现有配置文件，将创建新文件');
                }

                // 检查是否已存在相同的 configId
                const existingIndex = existingConfigs.findIndex(config => config.configId === configId);
                
                if (existingIndex !== -1) {
                    // 如果存在，更新现有配置
                    existingConfigs[existingIndex] = configData;
                    messageArea.textContent = '配置已更新!';
                } else {
                    // 如果不存在，添加新配置
                    existingConfigs.push(configData);
                    messageArea.textContent = '新配置已添加!';
                }

                // 创建包含所有配置的文本内容
                const configContent = JSON.stringify(existingConfigs, null, 2);

                // 创建 Blob 对象
                const blob = new Blob([configContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                // 创建下载链接
                const a = document.createElement('a');
                a.href = url;
                a.download = 'scene_3d_config.json';
                document.body.appendChild(a);
                
                // 触发下载
                a.click();
                
                // 清理
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                messageArea.style.color = 'green';
                messageArea.textContent += '\n请将下载的文件替换 public/prompts/scene_3d_config.json';
                saveModal.style.display = 'none';
                
                // 清空表单
                configIdInput.value = '';
                configNameInput.value = '';
                configDescriptionInput.value = '';

            } catch (error) {
                console.error('保存配置失败:', error);
                messageArea.textContent = `保存失败: ${error.message}`;
                messageArea.style.color = 'red';
            }
        }
    </script>
</body>
</html>