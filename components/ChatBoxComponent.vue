/**
 * @fileoverview 聊天框组件 - 使用扣子(Coze)工作流API
 */

<template>
  <div class="chat-box fixed right-0 top-0 bottom-0 p-4 flex items-center">
    <div class="w-[400px] h-[80vh] rounded-2xl shadow-2xl overflow-hidden bg-gradient-to-b from-black/20 to-black/30 backdrop-blur-sm border border-white/20 flex flex-col">
      <!-- 消息容器 -->
              <div class="messages-container flex-1 overflow-y-auto p-4 mb-2 rounded-t-2xl">
        <transition-group name="fade" tag="div" class="space-y-4">
          <div
              v-for="(msg, index) in messages"
              :key="msg.id"
              class="message p-4 rounded-2xl transform transition-all duration-300 hover:scale-[1.02] flex flex-col"
              :class="[
                msg.from === 'user' ? 'items-end' : 'items-start',
                'w-full'
              ]"
          >
            <div
              class="message-content px-4 py-3 rounded-xl max-w-[90%] text-sm"
              :class="msg.from === 'user' ? 'bg-gradient-to-r from-blue-500/80 to-blue-600/80 text-white backdrop-blur-sm' : 'bg-gradient-to-r from-white/80 to-gray-100/80 text-gray-800 backdrop-blur-sm'"
            >
              {{ msg.text }}
            </div>
          </div>
        </transition-group>
        
        <!-- 评估结果显示区域 -->
        <div v-if="showEvaluation" class="evaluation-results bg-gradient-to-r from-yellow-50/80 to-orange-50/80 text-gray-800 rounded-xl p-3 my-3 border border-yellow-200/50 shadow-lg backdrop-blur-sm">
          <h3 class="text-lg font-bold mb-3 text-yellow-700">訓練評估結果</h3>
          <div class="rating flex items-center mb-3">
            <span class="mr-2 font-medium">評分:</span>
            <div class="rating-stars flex items-center bg-white px-3 py-1 rounded-full shadow-sm">
              <span 
                v-for="i in 10" 
                :key="i" 
                :class="[
                  'transition-all duration-300 transform',
                  i <= evaluationRating ? 'text-yellow-400 scale-110' : 'text-gray-300'
                ]"
              >★</span>
              <span class="ml-2 font-bold text-yellow-600">{{ evaluationRating }}/10</span>
            </div>
          </div>
          <div class="evaluation-msg bg-white rounded-xl p-3 shadow-inner mb-3">
            <p class="text-sm font-medium text-gray-700 mb-1">改進建議:</p>
            <p class="text-sm text-gray-600 leading-relaxed">{{ evaluationMsg }}</p>
          </div>
          <!-- 可折叠的评估理由框 -->
          <div v-if="evaluationReasoning" class="reasoning-section">
            <button 
              @click="showReasoning = !showReasoning"
              class="w-full text-left bg-blue-50/80 hover:bg-blue-100/80 rounded-lg p-2 transition-all duration-200 flex items-center justify-between text-sm font-medium text-blue-700"
            >
              <span>📋 評估詳細理由</span>
              <svg 
                :class="['w-4 h-4 transition-transform duration-200', showReasoning ? 'rotate-180' : '']"
                fill="none" stroke="currentColor" viewBox="0 0 24 24"
              >
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
              </svg>
            </button>
            <div 
              v-show="showReasoning" 
              class="reasoning-content bg-white rounded-lg p-3 mt-2 shadow-inner border border-blue-100 text-xs text-gray-600 leading-relaxed max-h-48 overflow-y-auto"
            >
              <pre class="whitespace-pre-wrap font-mono">{{ evaluationReasoning }}</pre>
            </div>
          </div>
        </div>
      </div>

      <!-- 输入区域 -->
      <div class="flex-shrink-0 p-4 pt-2 pb-4 border-t border-gray-200/50">
        <form @submit.prevent="sendMessage" class="space-y-3">
          <div class="relative flex gap-2">
            <textarea
                v-model="userInput"
                ref="textareaRef"
                placeholder="输入消息..."
                class="flex-1 px-4 py-3 bg-white/70 border border-gray-200/50 rounded-lg shadow-inner focus:ring-2 focus:ring-blue-500/50 focus:border-transparent transition-all duration-300 outline-none backdrop-blur-sm text-sm resize-none min-h-[3rem]"
                :disabled="trainingFinished"
                @input="adjustTextareaHeight"
                @keydown.enter.exact.prevent="sendMessage"
                @keydown.enter.shift.exact="insertNewline"
                rows="1"
            ></textarea>
            <button
                type="submit"
                :disabled="!userInput.trim() || trainingFinished"
                class="send-btn bg-gradient-to-r from-blue-500 to-blue-600 text-white px-4 py-3 rounded-lg shadow-lg transition-all duration-300 hover:shadow-xl hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center min-w-[3rem] h-12 group"
                title="发送消息 (Enter)"
            >
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 transition-transform duration-200 group-hover:translate-x-0.5">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5" />
              </svg>
            </button>
          </div>
          <div class="flex justify-center gap-3">
            <!-- 训练中按钮组 -->
            <template v-if="!trainingFinished">
              <button
                  type="button"
                  @mousedown="startPressToTalk"
                  @mouseup="stopPressToTalk"
                  @mouseleave="stopPressToTalk"
                  @touchstart.prevent="startPressToTalk"
                  @touchend.prevent="stopPressToTalk"
                  :class="[
                    'voice-btn relative overflow-hidden h-14 flex-1 min-w-[8rem]',
                    isRecording ? 'voice-btn-recording' : 'voice-btn-normal'
                  ]"
                  :disabled="trainingFinished"
              >
                <div class="voice-btn-content">
                  <div class="voice-icon">🎤</div>
                  <span class="voice-text">{{ isRecording ? "正在录音..." : "按住说话" }}</span>
                </div>
                
                <!-- 录音时的波纹效果 -->
                <div v-if="isRecording" class="voice-ripple"></div>
                <div v-if="isRecording" class="voice-ripple voice-ripple-delay"></div>
              </button>
              <button
                  type="button"
                  @click="finishTraining"
                  :disabled="isEvaluating || messages.length === 0"
                  class="btn-primary bg-gradient-to-r from-purple-500 to-purple-600 h-14 flex-1 min-w-[8rem]"
              >
                ✓ 完成训练
              </button>
            </template>
            
            <!-- 训练后按钮组 -->
            <template v-else>
              <div v-if="!showEvaluation" class="flex gap-3 w-full">
                <button
                    type="button"
                    @click="evaluateConversation"
                    :disabled="isEvaluating"
                    class="btn-primary bg-gradient-to-r from-blue-500 to-blue-600 h-14 flex-1 min-w-[8rem]"
                >
                  📝 {{ isEvaluating ? "評估中" : "評估" }}
                </button>
              </div>
              <div v-else class="flex gap-3 w-full">
                <button
                    type="button"
                    @click="resetTraining"
                    class="btn-primary bg-gradient-to-r from-green-500 to-green-600 h-14 flex-1 min-w-[7rem]"
                >
                  🔄 再次訓練
                </button>
                <button
                    type="button"
                    @click="goToHome"
                    class="btn-primary bg-gradient-to-r from-purple-500 to-purple-600 h-14 flex-1 min-w-[7rem]"
                >
                  🏠 回到主頁
                </button>
              </div>
            </template>
          </div>
        </form>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, nextTick, watch, onBeforeUnmount } from 'vue';
import axios from 'axios';
import { useRouter, useRoute } from 'vue-router';

const router = useRouter();
const route = useRoute();

const messages = ref([]);
const userInput = ref("");
const textareaRef = ref(null);
const isRecording = ref(false);
const audioBlob = ref(null);
const trainingFinished = ref(false);
const isEvaluating = ref(false);
const showEvaluation = ref(false);
const evaluationRating = ref(0);
const evaluationMsg = ref("");
const evaluationReasoning = ref(""); // 新增：评估理由
const showReasoning = ref(false); // 控制理由框的展开/折叠
const currentSceneId = ref(null);

let mediaRecorder;
let audioChunks = [];
let sttSessionId = null;
let audioContext = null;
let processor = null;

// 清空聊天记录
const clearChat = async () => {
  // console.log('清空聊天记录');
  
  try {
    // 调用API清除conversation_id
    await axios.post("/api/coze-conversation", {
      action: 'clearHistory',
      userId: 'default_user'
    });
  } catch (error) {
    console.error('清除对话历史失败:', error);
  }
  
  messages.value = [];
  userInput.value = "";
  isRecording.value = false;
  audioBlob.value = null;
  trainingFinished.value = false;
  isEvaluating.value = false;
  showEvaluation.value = false;
  evaluationRating.value = 0;
  evaluationMsg.value = "";
  audioChunks = [];
  
  // 停止录音（如果在录音中）
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
  }
};

// 初始化当前场景ID
const initCurrentScene = () => {
  try {
    if (process.client) {
      const sceneData = localStorage.getItem('currentScene');
      if (sceneData) {
        const scene = JSON.parse(sceneData);
        currentSceneId.value = scene.scene_id; // 使用scene_id字段，如 'vascular_tumor_001'
      }
    }
  } catch (error) {
    console.error('初始化场景时出错:', error);
  }
};

// 获取预加载的角色信息
const getCurrentSceneCharacter = () => {
  // 直接从全局变量获取预加载的角色信息
  if (window.currentSceneCharacter) {
    // console.log(`使用预加载的角色信息: ${window.currentSceneCharacter.name} (${window.currentSceneCharacter.voice})`);
    return window.currentSceneCharacter;
  }
  
  // 如果没有预加载信息，抛出错误
  console.error('未找到预加载的角色信息，无法继续');
  throw new Error('角色信息未预加载，请确认场景配置正确');
};

// 组件挂载时
onMounted(() => {
  try {
    // 初始化当前场景ID
    initCurrentScene();
    // 初始化textarea高度
    nextTick(() => {
      adjustTextareaHeight();
    });
  } catch (error) {
    console.error('组件挂载时出错:', error);
  }
});

// 滚动到底部
const scrollToBottom = async () => {
  await nextTick();
  const container = document.querySelector('.messages-container');
  if (container) {
    container.scrollTop = container.scrollHeight;
  }
};

// 监听消息变化，自动滚动到底部
watch(messages, () => {
  scrollToBottom();
}, { deep: true });

const sendMessage = async () => {
  const userMessage = userInput.value.trim();
  if (!userMessage || trainingFinished.value) {
    return;
  }

  const newMessage = {
    id: Date.now(),
    text: userMessage,
    from: 'user'
  };

  messages.value.push(newMessage);
  userInput.value = "";

  // 重置textarea高度
  nextTick(() => {
    adjustTextareaHeight();
  });

  try {
    // 从localStorage获取当前场景信息
    let systemPrompt = "你是一位经验丰富的医生，正在接受培训者的问诊训练。请根据培训者的问题，给出专业、耐心的回答。";
    let sceneId = null;
    let isNewScene = false;
    
    if (process.client) {
      const sceneData = localStorage.getItem('currentScene');
      if (sceneData) {
        try {
          const scene = JSON.parse(sceneData);
          if (scene.scene_description_model) {
            systemPrompt = scene.scene_description_model;
          }
          
          // 检查场景是否变更
          if (scene.scene_id !== currentSceneId.value) {
            isNewScene = true;
            // 更新当前场景ID
            currentSceneId.value = scene.scene_id;
          }
          
          sceneId = scene.scene_id; // 使用scene_id字段，如 'vascular_tumor_001'
        } catch (error) {
          console.error('解析场景数据失败:', error);
        }
      }
    }

    // console.log('Sending message to API:', userMessage);
    const aiResponse = await axios.post("/api/coze-conversation", { 
        message: userMessage,
        systemPrompt: systemPrompt,
        userId: 'default_user', // 或者使用实际的用户ID
        scenarioId: sceneId,
        shouldSave: false // 训练过程中不保存，完成后再保存
    });
    
    if (aiResponse?.data?.error) {
      throw new Error(aiResponse.data.error);
    }
    
    const reply = aiResponse?.data?.response || "I didn't understand that.";
    const aiMessage = {
      id: Date.now(),
      text: reply,
      from: 'ai'
    };
    messages.value.push(aiMessage);

    // 转换AI回复为语音并播放，在语音开始播放时控制角色动画
    try {
      // 获取预加载的角色信息（无需异步调用）
      const currentCharacter = getCurrentSceneCharacter();
      const characterName = currentCharacter.name;

      // console.log('开始生成语音...');
      // 调用新的Edge TTS API，传入角色名称
      const speechResponse = await axios.post("/api/text-to-speech", { 
        text: reply,
        characterName: characterName
      });
      
      if (!speechResponse.data.success) {
        throw new Error(speechResponse.data.error || '语音生成失败');
      }

    const audioContent = speechResponse.data.audioContent;
      // console.log(`语音生成完成，使用音色: ${speechResponse.data.voice}`);

      // 创建音频对象
    const audioBlob = new Blob([Uint8Array.from(atob(audioContent), c => c.charCodeAt(0))], { type: 'audio/mp3' });
    const audioUrl = URL.createObjectURL(audioBlob);
    const audio = new Audio(audioUrl);
      
        // 监听音频开始播放，启动说话动画
        audio.addEventListener('play', () => {
          if (window.playTalkAnimation) {
            window.playTalkAnimation(true);
            // console.log('语音开始播放，启动说话动画');
          }
        });

        // 监听音频播放结束，停止说话动画
        audio.addEventListener('ended', () => {
          if (window.playTalkAnimation) {
            window.playTalkAnimation(false);
            // console.log('语音播放结束，停止说话动画');
          }
          URL.revokeObjectURL(audioUrl); // 清理URL对象
        });

        // 监听音频播放错误
        audio.addEventListener('error', (e) => {
          console.error('音频播放失败:', e);
          if (window.playTalkAnimation) {
            window.playTalkAnimation(false);
            // console.log('音频播放失败，停止说话动画');
          }
          URL.revokeObjectURL(audioUrl);
        });

        // 监听音频暂停（以防万一）
        audio.addEventListener('pause', () => {
          if (window.playTalkAnimation) {
            window.playTalkAnimation(false);
            // console.log('语音播放暂停，停止说话动画');
          }
        });

        // 开始播放音频（此时会触发play事件，启动动画）
        // console.log('准备播放语音...');
    audio.play();
    } catch (ttsError) {
      console.error('TTS处理失败:', ttsError);
      // TTS失败时不需要停止动画，因为动画还没开始
    }
  } catch (error) {
    console.error('Error sending message:', error);
    alert('發送消息失敗：' + error.message);
  }
};

// 按住说话 - 开始
const startPressToTalk = async (event) => {
  if (trainingFinished.value || isRecording.value) return;
  
  // 防止默认行为和事件冒泡
  event.preventDefault();
  event.stopPropagation();
  
  try {
    await startRecording();
  } catch (error) {
    console.error('开始录音失败:', error);
  }
};

// 按住说话 - 结束
const stopPressToTalk = async (event) => {
  if (trainingFinished.value || !isRecording.value) return;
  
  // 防止默认行为和事件冒泡
  event.preventDefault();
  event.stopPropagation();
  
  try {
    await stopRecording();
  } catch (error) {
    console.error('停止录音失败:', error);
  }
};

const startRecording = async () => {
  if (trainingFinished.value) return;
  
  try {
    // 检查浏览器是否支持媒体设备API
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error('您的瀏覽器不支持音頻錄製功能');
    }

    // console.log('🎤 开始流式录音...');
    isRecording.value = true;
    
    const stream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        sampleRate: 16000,
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true
      }
    });
    
    // 保存stream引用用于停止时清理
    window.currentAudioStream = stream;

    // 创建音频上下文
    audioContext = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: 16000
    });
    
    const source = audioContext.createMediaStreamSource(stream);
    
    // 创建ScriptProcessor或AudioWorklet进行实时音频处理
    processor = audioContext.createScriptProcessor(4096, 1, 1);
    
    // 初始化STT会话
    await initSTTSession();
    
    let audioBuffer = [];
    
    // 将audioBuffer保存到window对象供停止录音时访问
    window.audioBufferData = audioBuffer;
    
    processor.onaudioprocess = async (e) => {
      if (!isRecording.value || !sttSessionId) return;
      
      const inputBuffer = e.inputBuffer;
      const inputData = inputBuffer.getChannelData(0);
      
      // 转换为16位PCM（小端序）
      const pcmData = new Int16Array(inputData.length);
      for (let i = 0; i < inputData.length; i++) {
        // 确保样本在[-1, 1]范围内
        const sample = Math.max(-1, Math.min(1, inputData[i]));
        // 转换为16位整数
        pcmData[i] = sample < 0 ? Math.floor(sample * 0x8000) : Math.floor(sample * 0x7FFF);
      }
      
      // 转换为字节数组（小端序）
      const bytes = new Uint8Array(pcmData.buffer);
      audioBuffer.push(...bytes);
      
      // 每200ms发送一次数据 (16000 * 2 * 0.2 = 6400 bytes)
      // HTTP请求不适合太频繁，调整为200ms
      if (audioBuffer.length >= 6400) {
        const chunkData = new Uint8Array(audioBuffer.splice(0, 6400));
        await sendAudioData(chunkData, false);
          }
    };
    
    source.connect(processor);
    processor.connect(audioContext.destination);
    
    // console.log('✅ 流式录音已开始');

  } catch (error) {
    console.error('启动录音失败:', error);
    isRecording.value = false;
    alert(error.message || '無法訪問麥克風，請檢查權限設置');
  }
};

const stopRecording = async () => {
  if (!isRecording.value) return;
  
  // console.log('🛑 停止流式录音...');
  isRecording.value = false;
  
  // 发送剩余的音频数据（如果有的话）
  if (sttSessionId && processor) {
    // 获取当前audioBuffer中的剩余数据
    const audioBufferData = window.audioBufferData || [];
    if (audioBufferData.length > 0) {
      // console.log(`📤 发送剩余音频数据: ${audioBufferData.length} bytes`);
      await sendAudioData(new Uint8Array(audioBufferData), false);
      window.audioBufferData = [];
    }
    
    // 发送结束标记
    await sendAudioData(new Uint8Array(0), true);
  }
  
  // 清理音频处理
  if (processor) {
    processor.disconnect();
    processor = null;
  }
  
  if (audioContext) {
    audioContext.close();
    audioContext = null;
  }
  
  // 停止音频流
  if (window.currentAudioStream) {
    window.currentAudioStream.getTracks().forEach(track => {
      track.stop();
      // console.log('🔇 停止音频轨道:', track.kind);
    });
    window.currentAudioStream = null;
  }
  
  // 关闭STT会话
  if (sttSessionId) {
    try {
      await axios.post("/api/speech-to-text-stream", {
        action: 'close',
        sessionId: sttSessionId
      });
    } catch (error) {
      console.error('关闭STT会话失败:', error);
    }
    sttSessionId = null;
  }
};

// 初始化STT会话
const initSTTSession = async () => {
  try {
    // console.log('🔗 初始化流式STT会话...');
    
    const response = await axios.post("/api/speech-to-text-stream", {
      action: 'init'
    });
    
    if (!response.data.success) {
      throw new Error(response.data.error || 'STT会话初始化失败');
    }
    
    sttSessionId = response.data.sessionId;
    // console.log('✅ STT会话初始化成功:', sttSessionId);
    
  } catch (error) {
    console.error('初始化STT会话失败:', error);
    throw error;
  }
};

// 发送音频数据
const sendAudioData = async (audioData, isLast) => {
  if (!sttSessionId) {
    console.warn('STT会话未初始化');
    return;
  }

  try {
    const response = await axios.post("/api/speech-to-text-stream", {
      action: 'sendAudio',
      sessionId: sttSessionId,
      audioData: Array.from(audioData),
      isLast: isLast
    });
    
    if (response.data.success) {
      const result = response.data.result;
      
      if (result && result.trim()) {
        // console.log('🎯 识别结果:', result);
        userInput.value = result;
        
        // 只显示在文本框中，不自动发送
      }
    }
    
  } catch (error) {
    console.error('发送音频数据失败:', error);
  }
};

const downloadAudio = () => {
  if (!audioBlob.value) {
    return;
  }

  const link = document.createElement('a');
  link.href = URL.createObjectURL(audioBlob.value);
  link.download = 'recorded_audio.wav';
  link.click();
  URL.revokeObjectURL(link.href);
};

const getSupportedContentMimeType = () => {
  // 不再需要MediaRecorder的MIME类型检查，因为我们使用PCM格式
  return 'audio/pcm';
};

/**
 * 完成训练，准备评估
 */
const finishTraining = () => {
  if (messages.value.length === 0) {
    alert('還沒有對話內容可以評估！');
    return;
  }
  
  trainingFinished.value = true;
};

/**
 * 评估对话
 */
const evaluateConversation = async () => {
  if (messages.value.length === 0) {
    alert('還沒有對話內容可以評估！');
    return;
  }

  isEvaluating.value = true;

  try {
    // 过滤掉错误消息
    const validMessages = messages.value.filter(msg => msg.text !== "Error: Failed to send message.");

    // 获取当前场景ID（必须有效）
    let sceneId = null;
    if (process.client) {
      try {
        const sceneData = localStorage.getItem('currentScene');
        if (sceneData) {
          const scene = JSON.parse(sceneData);
          sceneId = scene.scene_id; // 使用scene_id字段，如 'vascular_tumor_001'
        }
      } catch (error) {
        console.error('获取场景ID失败:', error);
      }
    }
    
    if (!sceneId) {
      throw new Error('场景ID未找到，无法评估对话');
    }

    // 获取当前场景的完整数据
    let sceneData = null;
    if (process.client) {
      try {
        const storedSceneData = localStorage.getItem('currentScene');
        if (storedSceneData) {
          sceneData = JSON.parse(storedSceneData);
        }
      } catch (error) {
        console.error('获取场景数据失败:', error);
      }
    }

    if (!sceneData) {
      throw new Error('场景数据未找到，无法进行评估');
    }

    // 准备对话数据
    const conversationData = {
      userId: 'default_user',  // 使用与其他API一致的用户ID
      scenarioId: sceneId,
      messages: validMessages.map(msg => ({
        role: msg.from === 'user' ? 'user' : 'assistant',
        content: msg.text,
        timestamp: new Date()
      })),
      sceneData: sceneData  // 传递完整的场景数据
    };

    console.log('发送评估请求:', conversationData);
    console.log('场景数据:', {
      scene_id: sceneData.scene_id,
      scene_description_model: sceneData.scene_description_model?.substring(0, 100) + '...',
      scene_description_charactor: sceneData.scene_description_charactor?.substring(0, 100) + '...'
    });

    // 调用评估API
    const response = await axios.post("/api/evaluate-conversation", conversationData);
    
    console.log('评估API响应:', response.data);
    
    if (response.data.error) {
      throw new Error(response.data.error);
    }

    if (!response.data.success) {
      throw new Error('评估失败：' + (response.data.error || '未知错误'));
    }

    // 显示评估结果
    evaluationRating.value = response.data.rating;
    evaluationMsg.value = response.data.evaluation_msg;
    evaluationReasoning.value = response.data.reasoning || ''; // 保存评估理由
    showEvaluation.value = true;

    console.log('评估成功，评分:', response.data.rating, '评估消息:', response.data.evaluation_msg);
    console.log('评估理由:', response.data.reasoning?.substring(0, 100) + '...');
  } catch (error) {
    console.error('评估失败:', error);
    alert('對話評估失敗：' + error.message);
  } finally {
    isEvaluating.value = false;
  }
};

/**
 * 重置训练，开始新一轮
 */
const resetTraining = async () => {
  await clearChat();
  trainingFinished.value = false;
  showEvaluation.value = false;
  evaluationRating.value = 0;
  evaluationMsg.value = "";
  evaluationReasoning.value = "";
  showReasoning.value = false;
};

const goToHome = () => {
  // 实现回到主页的逻辑
  console.log('回到主页');
  router.push('/');
};

// 组件销毁时清理
onBeforeUnmount(async () => {
  // 停止录音
  if (isRecording.value) {
    await stopRecording();
  }
  
  // 停止音频流
  if (window.currentAudioStream) {
    window.currentAudioStream.getTracks().forEach(track => track.stop());
    window.currentAudioStream = null;
  }
  
  // 关闭STT会话
  if (sttSessionId) {
    try {
      await axios.post("/api/speech-to-text-stream", {
        action: 'close',
        sessionId: sttSessionId
      });
    } catch (error) {
      console.error('关闭STT会话失败:', error);
    }
  }
});

// 自动调整textarea高度
const adjustTextareaHeight = () => {
  const textarea = textareaRef.value;
  if (!textarea) return;
  
  // 重置高度以获取正确的scrollHeight
  textarea.style.height = 'auto';
  textarea.style.overflowY = 'hidden';
  
  // 计算行高和最大行数
  const lineHeight = 24; // 1.5 * 16px (text-sm的line-height)
  const padding = 24; // 上下padding各12px
  const minHeight = 48;  // 对应 min-h-[3rem] (3rem = 48px)
  const maxLines = 3;
  const maxHeight = padding + (lineHeight * maxLines); // 96px for 3 lines
  
  // 计算所需高度
  const scrollHeight = textarea.scrollHeight;
  const newHeight = Math.max(minHeight, scrollHeight);
  
  if (newHeight <= maxHeight) {
    // 在最大行数内，自动调整高度，不显示滚动条
    textarea.style.height = newHeight + 'px';
    textarea.style.overflowY = 'hidden';
  } else {
    // 超过最大行数，固定高度并显示滚动条
    textarea.style.height = maxHeight + 'px';
    textarea.style.overflowY = 'auto';
  }
};

// 插入换行符（Shift+Enter）
const insertNewline = () => {
  const textarea = textareaRef.value;
  if (!textarea) return;
  
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const value = userInput.value;
  
  userInput.value = value.substring(0, start) + '\n' + value.substring(end);
  
  // 下一帧设置光标位置和调整高度
  nextTick(() => {
    textarea.selectionStart = textarea.selectionEnd = start + 1;
    adjustTextareaHeight();
  });
};
</script>

<style scoped>
.chat-box {
  z-index: 10;
  pointer-events: none; /* 让背景可以点击 */
}

.chat-box > div {
  pointer-events: auto; /* 恢复聊天框的点击事件 */
}

/* 添加响应式样式 */
@media (max-width: 768px) {
  .chat-box {
    position: fixed;
    right: 0;
    bottom: 0;
    top: auto;
    left: 0;
    padding: 0.5rem;
    align-items: flex-end;
  }
  
  .chat-box > div {
    width: 100%;
    height: 60vh;
  }
}

.messages-container {
  scrollbar-width: thin;
  scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
}

.messages-container::-webkit-scrollbar {
  width: 4px;
}

.messages-container::-webkit-scrollbar-track {
  background: transparent;
}

.messages-container::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 2px;
}

.message {
  transition: all 0.3s ease;
  word-wrap: break-word;
}

.message-content {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.btn-primary {
  /* height由h-14类控制，与语音按钮保持一致 */
  min-width: 4.5rem;
  color: white;
  padding-left: 1rem;
  padding-right: 1rem;
  border-radius: 0.75rem;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.875rem;
  font-weight: 500;
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  transition: all 0.3s ease;
}

.btn-primary:hover {
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  transform: scale(1.05);
}

.btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.fade-enter-active,
.fade-leave-active {
  transition: all 0.3s ease;
}

.fade-enter-from {
  opacity: 0;
  transform: translateY(20px);
}

.fade-leave-to {
  opacity: 0;
  transform: translateY(-20px);
}

.evaluation-results {
  animation: slideIn 0.5s ease;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* 添加鼠标悬停效果 */
.message-content:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* 输入框激活状态 */
input:focus {
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

/* 发送按钮样式 */
.send-btn {
  border: none;
  cursor: pointer;
}

.send-btn:hover:not(:disabled) {
  background: linear-gradient(135deg, #2563eb, #1d4ed8);
}

.send-btn:active:not(:disabled) {
  transform: scale(0.95);
}

.send-btn:disabled {
  background: #9ca3af;
  transform: none;
}

/* 语音按钮样式 */
.voice-btn {
  position: relative;
  /* height由h-14类控制，确保与其他按钮一致 */
  border: none;
  border-radius: 1.5rem;
  font-weight: 600;
  font-size: 0.875rem;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  cursor: pointer;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}

.voice-btn-normal {
  background: linear-gradient(135deg, #10b981, #059669);
  color: white;
  box-shadow: 0 4px 14px 0 rgba(16, 185, 129, 0.4);
}

.voice-btn-normal:hover {
  background: linear-gradient(135deg, #059669, #047857);
  box-shadow: 0 6px 20px 0 rgba(16, 185, 129, 0.6);
  transform: translateY(-1px);
}

.voice-btn-normal:active {
  transform: scale(1.1) translateY(-2px);
  box-shadow: 0 8px 25px 0 rgba(16, 185, 129, 0.8);
}

.voice-btn-recording {
  background: linear-gradient(135deg, #ef4444, #dc2626);
  color: white;
  transform: scale(1.15);
  box-shadow: 0 8px 30px 0 rgba(239, 68, 68, 0.7);
  animation: pulse-recording 1.5s ease-in-out infinite;
}

.voice-btn-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  position: relative;
  z-index: 2;
}

.voice-icon {
  font-size: 1.25rem;
  display: block;
  line-height: 1;
}

.voice-text {
  font-size: 0.75rem;
  font-weight: 500;
  opacity: 0.9;
  line-height: 1;
  margin-top: 2px;
}

/* 波纹效果 */
.voice-ripple {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%) scale(0);
  animation: ripple 2s linear infinite;
  z-index: 1;
}

.voice-ripple-delay {
  animation-delay: 1s;
}

@keyframes pulse-recording {
  0%, 100% {
    box-shadow: 0 8px 30px 0 rgba(239, 68, 68, 0.7);
  }
  50% {
    box-shadow: 0 12px 40px 0 rgba(239, 68, 68, 0.9);
  }
}

@keyframes ripple {
  0% {
    transform: translate(-50%, -50%) scale(0);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(2);
    opacity: 0;
  }
}

/* 禁用状态 */
.voice-btn:disabled {
  background: #9ca3af !important;
  transform: none !important;
  cursor: not-allowed;
  box-shadow: none !important;
  animation: none !important;
}

.voice-btn:disabled .voice-ripple {
  display: none;
}

/* 响应式输入框布局 */
@media (max-width: 640px) {
  .send-btn {
    min-width: 2.5rem;
    padding-left: 0.75rem;
    padding-right: 0.75rem;
  }
  
  .voice-btn {
    /* height由h-14类控制 */
  }
  
  .voice-icon {
    font-size: 1.1rem;
  }
  
  .voice-text {
    font-size: 0.7rem;
  }
  
  textarea {
    font-size: 0.875rem;
  }
  
  .chat-box > div {
    width: 100%;
    height: 70vh;
  }
}

/* Textarea样式增强 */
textarea {
  line-height: 1.5;
  word-wrap: break-word;
  white-space: pre-wrap;
  transition: height 0.15s ease-out;
}

textarea::placeholder {
  color: #9ca3af;
  opacity: 1;
}

textarea:focus::placeholder {
  opacity: 0.5;
}

/* 自定义滚动条样式 */
textarea::-webkit-scrollbar {
  width: 6px;
}

textarea::-webkit-scrollbar-track {
  background: transparent;
}

textarea::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

textarea::-webkit-scrollbar-thumb:hover {
  background-color: rgba(0, 0, 0, 0.3);
}
</style>